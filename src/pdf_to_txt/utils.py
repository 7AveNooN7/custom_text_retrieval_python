from collections import defaultdict
from difflib import SequenceMatcher
import re
from typing import List, Set

import unicodedata
from tqdm import tqdm

from src.config import EXCLUDED_TITLES, EXCLUDED_STRUCTURAL_ELEMENTS
from src.pdf_to_txt.string_ratio_scores import partial_ratio_by_whole_words_score


def is_title_similar_to_excluded_titles(title, threshold):
    for excluded_title in EXCLUDED_TITLES:
        if partial_ratio_by_whole_words_score(title, excluded_title) > threshold:
            return True
    return False

def is_title_similar_to_excluded_structural_elements(title):
    for excluded_structural_element in EXCLUDED_STRUCTURAL_ELEMENTS:
        split_title = title.split()
        if SequenceMatcher(None, excluded_structural_element, split_title[0]).ratio() > 0.95:
            return True
    return False

def has_numbering(title):
    """Sprawdza, czy tytuÅ‚ zawiera numeracjÄ™ rzymskÄ… lub arabskÄ…."""
    return bool(re.search(r'\b(\d+|[IVXLCDM]+)\b', title, re.IGNORECASE))

def clean_title(title):
    # Normalizacja Unicode (usuwa ukryte znaki)
    title = unicodedata.normalize("NFKC", title)

    # ZastÄ…pienie znakÃ³w nowej linii (CR, LF) spacjÄ…
    title = title.replace('\r', ' ').replace('\n', ' ')

    # UsuniÄ™cie niewidocznych lub zerowej szerokoÅ›ci znakÃ³w
    # (czyli wszystkich znakÃ³w niebÄ™dÄ…cych "drukowalnymi")
    title = ''.join(ch for ch in title if ch.isprintable())

    if ".pdf" in title:
        #print(f'âŒ {title}: Entry changed - title contains ".pdf!"')
        title = title.replace(".pdf", "")

    if ":" in title:
        #print(f'âŒ {title}: Entry changed - title contains ":"!')
        title = title.replace(":", "")

    # PrzyciÄ™cie biaÅ‚ych znakÃ³w na poczÄ…tku i koÅ„cu
    return title.strip()

roman_or_arabic_pattern = re.compile(r"^(?:[IVXLCDMivxlcdm]+|\d+)$")

def clean_title_from_repeated_words(title: str, repeated_words: list[str]) -> str:
    """
    Usuwa z tytuÅ‚u sÅ‚owa z listy repeated_words
    wraz z nastÄ™pujÄ…cym po nich tokenem,
    jeÅ›li ten token wyglÄ…da na liczbÄ™ arabskÄ… lub rzymskÄ….

    PrzykÅ‚ad:
      "Chapter 1 Blood sampling" -> "Blood sampling"
      (jeÅ›li "chapter" jest w repeated_words)
    """
    # Rozbijamy tytuÅ‚ na sÅ‚owa
    tokens = title.split()

    cleaned_tokens = []
    skip_next = False  # flaga informujÄ…ca, Å¼e nastÄ™pny token teÅ¼ omijamy

    for i in range(len(tokens)):
        if skip_next:
            # poprzedni token byÅ‚ "chapter" i kolejny jest liczbÄ… -> pomijamy TEN token
            skip_next = False
            continue

        current_token = tokens[i]

        # Sprawdzamy, czy to "repeated word" (np. "chapter")
        if current_token.lower() in repeated_words:
            # Sprawdzamy, czy kolejny token istnieje i wyglÄ…da na liczbÄ™ arabskÄ… lub rzymskÄ…
            if i + 1 < len(tokens):
                next_token = tokens[i + 1]
                if roman_or_arabic_pattern.match(next_token):
                    # jeÅ›li tak, to ustawiamy skip_next, aby pominÄ…Ä‡ go w kolejnej iteracji
                    skip_next = True
            # i tak nie dodajemy bieÅ¼Ä…cego tokena do wyniku
        else:
            # Normalny token, ktÃ³ry nie jest "repeated word"
            cleaned_tokens.append(current_token)

    # Sklejamy z powrotem w string
    return " ".join(cleaned_tokens)


def are_titles_similar(searched_title: str, text_from_block: str, repeated_words: list[str], threshold=0.7):
    """
    PorÃ³wnuje dwa tytuÅ‚y i zwraca True, jeÅ›li sÄ… wystarczajÄ…co podobne.
    - JeÅ›li sÄ… identyczne â†’ True
    - JeÅ›li oba majÄ… numeracjÄ™ (np. 'PART I' i 'PART II'), wymagamy precyzyjnego dopasowania
    - JeÅ›li sÄ… tylko czÄ™Å›ciowo podobne, ale rÃ³Å¼niÄ… siÄ™ istotnie, zwracamy False
    """

    searched_title = clean_title(searched_title)
    searched_title = clean_title_from_repeated_words(searched_title, repeated_words)
    searched_title = searched_title.strip().lower()

    text_from_block = clean_title(text_from_block)
    text_from_block = clean_title_from_repeated_words(title=text_from_block, repeated_words=repeated_words)
    text_from_block = text_from_block.strip().lower()

    # 3ï¸âƒ£ Klasyczne podobieÅ„stwo, jeÅ›li nie majÄ… numeracji
    similarity = SequenceMatcher(None, searched_title, text_from_block).ratio()

    return similarity >= threshold  # Standardowy prÃ³g podobieÅ„stwa (np. 90%)


def find_missing_chapters(doc, chapters_info, repeated):
    """
    Jedna lista: chapters_info = valid + invalid
    Tyle Å¼e 'valid' juÅ¼ majÄ… start_page i end_page ustawione,
    'invalid' majÄ… -1.
    """
    total_pages = len(doc)

    i = 0
    n = len(chapters_info)

    progress_bar = tqdm(range(total_pages), desc="ğŸ“– Przeszukiwanie stron PDF", unit="strona", leave=True,
                        dynamic_ncols=True)

    for page_num in range(total_pages):
        if i >= n:
            break

        # tqdm.write(f"ğŸ” Strona {page_num + 1} | Sprawdzam rozdziaÅ‚: {chapters_info[i]['title'] if i < n else 'Koniec'}")
        # ğŸ”¹ Aktualizujemy pasek tqdm, Å¼eby pokazywaÅ‚ aktualny rozdziaÅ‚
        progress_bar.set_postfix(
            {"Strona": page_num + 1, "Szukany rozdziaÅ‚": chapters_info[i]["title"] if i < n else "Koniec"})
        progress_bar.update(1)

        page = doc[page_num]
        blocks = page.get_text("blocks")
        blocks_sorted = sorted(blocks, key=lambda b: b[1])
        top_blocks = blocks_sorted[:3]

        while i < n:
            current_ch = chapters_info[i]

            # Czy ten rozdziaÅ‚ jest "invalid" (nieustalony)?
            if current_ch["start_page"] != -1:
                # On jest "valid", wiÄ™c idziemy do nastÄ™pnego
                i += 1
                continue

            searched_title = current_ch["title"]

            # Sprawdzamy czy w top-5 blokach jest 'searched_title'
            repeated_word = repeated[0]

            searched_title_found = False
            title_matched_block_text = ''

            key_word_found = False
            excluded_found = False
            for block in top_blocks:
                block_text = block[4]

                if searched_title_found == False and searched_title and are_titles_similar(
                        searched_title=searched_title, text_from_block=block_text, repeated_words=repeated,
                        threshold=0.85):
                    title_matched_block_text = block_text
                    searched_title_found = True

                if excluded_found == False and searched_title_found and is_title_similar_to_excluded_titles(
                        block_text, 0.75):
                    for tb in top_blocks:
                        # tb[4] to tekst w danym bloku
                        if len(tb[4]) < 100 and is_title_similar_to_excluded_titles(tb[4], 0.75):
                            tqdm.write(
                                f"âŒ '{searched_title}' â€” pominiÄ™ty, poniewaÅ¼ w top-blocks znaleziono EXCLUSION_TITLES")
                            excluded_found = True
                            break

                if key_word_found == False and partial_ratio_by_whole_words_score(block_text, repeated_word) > 0.8:
                    key_word_found = True

            if searched_title_found and key_word_found and not excluded_found:
                # ZwiÄ™kszamy i, Å¼eby przejÅ›Ä‡ do kolejnego rozdziaÅ‚u
                current_ch["start_page"] = page_num
                tqdm.write(f"âœ… {searched_title} -> start_page = {page_num}")
                i += 1
                # PRINT
                tqdm.write(f'Found against block:\n{title_matched_block_text.strip()}')
            else:
                # Nie znaleÅºliÅ›my nic na tej stronie -> idziemy do next strony
                break

    # -> (C) Po zakoÅ„czeniu pÄ™tli stronic => ustalamy end_page
    #    W oparciu o (i+1).start_page lub total_pages

    for idx in range(n):
        # JeÅ›li end_page jest -1
        if chapters_info[idx]["end_page"] == -1:
            if idx + 1 < n:
                # JeÅ›li rozdziaÅ‚ i+1 ma start_page != -1
                next_sp = chapters_info[idx + 1]["start_page"]
                if next_sp != -1:
                    chapters_info[idx]["end_page"] = (next_sp - 1)
                    tqdm.write(f"{chapters_info[idx]['title']} -> end_page={next_sp - 1}")
                else:
                    # ten teÅ¼ jest -1 => brak pewnoÅ›ci, zostawimy do koÅ„ca PDF
                    chapters_info[idx]["end_page"] = total_pages
                    tqdm.write(f"{chapters_info[idx]['title']} -> end_page={total_pages}")
            else:
                # ostatni rozdziaÅ‚
                chapters_info[idx]["end_page"] = total_pages
                tqdm.write(f"{chapters_info[idx]['title']} -> end_page={total_pages}")

    # -> (D) ZwrÃ³Ä‡ chapters_info (wszystkie rozdziaÅ‚y)
    return chapters_info


def get_repeated_words(titles_words_sets: List[Set[str]], threshold: int = 2) -> list:
    """
    Zwraca listÄ™ sÅ‚Ã³w, ktÃ³re wystÄ™pujÄ… najczÄ™Å›ciej w tytuÅ‚ach, pod warunkiem,
    Å¼e sÅ‚owo pojawiÅ‚o siÄ™ w co najmniej `threshold` rÃ³Å¼nych tytuÅ‚ach.

    :param titles_words_sets: lista zbiorÃ³w sÅ‚Ã³w, np. [ {"chapter", "1"}, {"chapter", "2"}, ... ]
    :param threshold: minimalna liczba tytuÅ‚Ã³w, w ktÃ³rych sÅ‚owo musi siÄ™ pojawiÄ‡,
                      aby w ogÃ³le wziÄ…Ä‡ je pod uwagÄ™
    :return: lista sÅ‚Ã³w (1 lub wiÄ™cej, jeÅ›li jest remis), ktÃ³re wystÄ™pujÄ… najczÄ™Å›ciej,
             speÅ‚niajÄ…c prÃ³g `threshold`
    """
    # 1. Liczymy liczbÄ™ tytuÅ‚Ã³w, w ktÃ³rych wystÄ™puje dane sÅ‚owo
    word_in_titles_count = defaultdict(int)
    for words_set in titles_words_sets:
        for word in words_set:
            word_in_titles_count[word] += 1

    # 2. KtÃ³re sÅ‚owa przeszÅ‚y prÃ³g `threshold`?
    #    (czyli wystÄ™pujÄ… w >= threshold tytuÅ‚ach)
    candidates = [(word, count) for word, count in word_in_titles_count.items()
                  if count >= threshold]

    # JeÅ›li Å¼adne sÅ‚owo nie przekroczyÅ‚o progu, zwracamy pustÄ… listÄ™
    if not candidates:
        return []

    # 3. SpoÅ›rÃ³d sÅ‚Ã³w, ktÃ³re przeszÅ‚y prÃ³g, wybieramy to (lub te), ktÃ³re wystÄ™pujÄ… najczÄ™Å›ciej
    max_count = max(count for _, count in candidates)  # najwyÅ¼sza liczba tytuÅ‚Ã³w
    most_frequent_words = [word for word, count in candidates if count == max_count]

    return most_frequent_words